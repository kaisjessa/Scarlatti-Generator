#imports
import glob
import pickle
import random
from music21 import converter, instrument, note, chord

#returns character sequence from midi folder
def midi_to_text(file_path):
	#array of characters representing notes
	notes = []
	#go through all midi files in folder
	i = 1
	for file in glob.glob(file_path):
		i += 1
		#read the file
		midi = converter.parse(file)
		#current notes
		notes_to_parse = None
		notes_to_parse = midi.flat
		#print([e for e in midi.flat])
		#add notes and chords to array
		for element in notes_to_parse:
			if isinstance(element, note.Note):
				notes.append(str(element.pitch))
			elif isinstance(element, chord.Chord):
				notes.append('.'.join(str(n) for n in element.normalOrder))
			elif isinstance(element, note.Rest):
				notes.append(" rest")
	#return array
	return(notes)


def text_to_midi(prediction_array):
	offset = 0
	output_notes = []
	# create note and chord objects based on the values generated by the model
	for pattern in prediction_array:
		# pattern is a chord
		if ('.' in pattern) or pattern.isdigit():
			notes_in_chord = pattern.split('.')
			notes = []
			for current_note in notes_in_chord:
				new_note = note.Note(int(current_note))
				new_note.storedInstrument = instrument.Harpsichord()
				notes.append(new_note)
			new_chord = chord.Chord(notes)
			new_chord.offset = offset
			output_notes.append(new_chord)

		# pattern is a rest
		elif(pattern == " rest"):
			new_note = note.Rest()
			new_note.offset = offset
			new_note.storedInstrument = instrument.Harpsichord()
			output_notes.append(new_note)

		#pattern is a note
		else:
			new_note = note.Note(pattern)
			new_note.offset = offset
			new_note.storedInstrument = instrument.Harpsichord()
			output_notes.append(new_note)
		# increase offset each iteration so that notes do not stack
		offset += 0.5
	return output_notes


out = midi_to_text("data/small_scarlatti_midi/*.MID")
with open('data/training_data.pkl', 'wb') as f:
    pickle.dump([out], f)
print("done")

